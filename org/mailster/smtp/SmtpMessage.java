/*
 * Dumbster - a dummy SMTP server Copyright 2004 Jason Paul Kitchen Licensed
 * under the Apache License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License. You may obtain a copy of the
 * License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by
 * applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
 * OF ANY KIND, either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 */

/**
 * Mailster additions : Copyright (c) 2007 De Oliveira Edouard
 * <p>
 * Some modifications to original code have been made in order to get efficient
 * parsing and to make bug corrections.
 */
package org.mailster.smtp;

import java.io.UnsupportedEncodingException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.LinkedList;
import java.util.List;

import org.mailster.util.MailUtilities;

/**
 * Container for a complete SMTP message - headers and message body.
 */
public class SmtpMessage
{
    /** 
     * Headers. 
     */
    private SmtpHeadersInterface headers;
    
    /** 
     * Message body. 
     */
    private StringBuffer body;
    
    /** 
     * Recipients (read from envelope) 
     */
    private List<String> recipients;

    private SmtpMessagePart internalParts;
    private StringBuffer rawMessage = new StringBuffer();

    private String content;
    private String oldPreferredContentType;
    private String messageID;

    /**
     * Likewise, a global id for Message-ID generation.
     */
    private static int id = 0;

    /**
     * Constructor. Initializes headers Map and body buffer.
     */
    public SmtpMessage()
    {
        headers = new SmtpHeaders();
        body = new StringBuffer();
        recipients = new LinkedList<String>();
    }

    /**
     * Update the headers or body depending on the SmtpResponse object and line
     * of input.
     * 
     * @param response SmtpResponse object
     * @param params remainder of input line after SMTP command has been removed
     */
    public void store(SmtpResponse response, String params)
    {
        boolean log = response.getNextState() == SmtpState.DATA_HDR
                || response.getNextState() == SmtpState.DATA_BODY;
        if (params != null)
        {
            if (SmtpState.DATA_HDR == response.getNextState())
                headers.addHeaderLine(params);
            else if (SmtpState.DATA_BODY == response.getNextState())
            {
                String charset = getBodyCharset();
                if (charset != null)
                {
                    try
                    {
                        params = new String(params
                                .getBytes(SimpleSmtpServer.DEFAULT_CHARSET),
                                charset);
                    }
                    catch (UnsupportedEncodingException e)
                    {
                        e.printStackTrace();
                    }
                }
                body.append(params);
            }

            if (log)
            {
                rawMessage.append(params);
                if (response.getNextState() != SmtpState.DATA_BODY)
                    rawMessage.append('\n');
            }
        }
        else if (response.getNextState() == SmtpState.DATA_BODY)
            rawMessage.append('\n');
    }

    /**
     * Get a unique value to use 'as' a Message-ID. If the headers don't contain
     * a Message-ID header value, this implementation generates it by
     * concatenating the message object's <code>hashCode()</code>, a global
     * ID (incremented on every use), the current time (in milliseconds), the
     * string "Mailster", and this user's local address generated by
     * <code>InetAddress.getLocalHost()</code>. (The address defaults to
     * "localhost" if <code>getLocalHost()</code> returns null.)
     * 
     * @see java.net.InetAddress
     */
    public String getMessageID()
    {
        if (messageID == null)
        {
            messageID = getHeaderValue(SmtpHeadersInterface.MESSAGE_ID);
            if (messageID == null)
            {
                StringBuffer s = new StringBuffer(hashCode());
                s.append('.').append(id++).append(System.currentTimeMillis())
                        .append(".Mailster@");
                try
                {
                    InetAddress addr = InetAddress.getLocalHost();
                    if (addr != null)
                        s.append(addr.getAddress());
                    else
                        s.append("localhost");
                }
                catch (UnknownHostException e)
                {
                    s.append("localhost");
                }

                // Unique string is
                // <hashcode>.<id>.<currentTime>.Mailster@<host>
                messageID = s.toString();
            }
        }

        return messageID;
    }

    /**
     * Get the value(s) associated with the given header name.
     * 
     * @param name header name
     * @return value(s) associated with the header name
     */
    public String[] getHeaderValues(String name)
    {
        return headers.getHeaderValues(name);
    }

    /**
     * Get the first value associated with a given header name.
     * 
     * @param name header name
     * @return first value associated with the header name
     */
    public String getHeaderValue(String name)
    {
        return headers.getHeaderValue(name);
    }

    /**
     * Get the message body.
     * 
     * @return message body
     */
    public String getBody()
    {
        return body.toString();
    }

    public String getRawMessage()
    {
        return rawMessage.toString();
    }

    /**
     * String representation of the SmtpMessage.
     * 
     * @return a String
     */
    public String toString()
    {
        StringBuffer msg = new StringBuffer(headers.toString());
        msg.append('\n').append(body).append('\n');
        return msg.toString();
    }

    public SmtpHeadersInterface getHeaders()
    {
        return headers;
    }

    public String getDate()
    {
        return MailUtilities.getNonNullHeaderValue(getHeaders(),
                SmtpHeadersInterface.DATE);
    }

    public String getTo()
    {
        return getHeaderValue(SmtpHeadersInterface.TO);
    }
    
    public String getSubject()
    {
        return MailUtilities.getNonNullHeaderValue(getHeaders(),
                SmtpHeadersInterface.SUBJECT);
    }

    public SmtpMessagePart getInternalParts()
    {
        if (internalParts == null)
            internalParts = MailUtilities.parseInternalParts(this);

        return internalParts;
    }

    public String getContent(String preferredContentType)
    {
        if (content == null
                || !oldPreferredContentType.equals(preferredContentType))
        {
            oldPreferredContentType = preferredContentType;
            content = getInternalParts().getContent(preferredContentType);
            String upperContent = content.toUpperCase();
            if (upperContent.indexOf("<HTML>") == -1)
            {
                if (upperContent.indexOf("<BODY>") == -1)
                    content = "<html><head> <style type=\"text/css\"><!--\n" +
                        "html,body {margin:2px;font: 10px Verdana;}" +
                        "--></style></head><body>"
                        + content + "</body></html>";
                else
                    content = "<html>"+content+"</html>";
            }
        }

        return content;
    }

    /**
     * Get the charset specified in Content-Type header.
     * 
     * @return charset, null if none specified.
     */
    public String getBodyCharset()
    {
        return MailUtilities.getHeaderParameterValue(headers,
                SmtpHeadersInterface.CONTENT_TYPE,
                SmtpHeadersInterface.CHARSET_PARAMETER);
    }

    /**
     * Add a recipient to the list of recipients.
     */
    protected void addRecipient(String recipient)
    {
        recipients.add(recipient);
    }

    /**
     * Returns a List of the recipients of this message (from the SMTP
     * envelope). Bcc recipients are consequently exposed for testing.
     * 
     * @return the list of recipients
     */
    public List<String> getRecipients()
    {
        return recipients;
    }

    /**
     * Return the size of the content of this message in bytes. Return -1 if the
     * size cannot be determined.
     * <p>
     * Note that this number may not be an exact measure of the content size and
     * may or may not account for any transfer encoding of the content.
     * <p>
     * This implementation returns the size of the message body (if not null),
     * otherwise, it returns -1.
     * 
     * @return size of content in bytes
     */
    public int getSize()
    {
        String s = getBody();
        if (s != null)
            return s.length();

        return -1;
    }
}
